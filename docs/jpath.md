## JPath

Что такое JPath? Это способ для доступа к разным частям данных.
Способ описания, каким образом и что нужно извлечь из входящего дерева.
Результатом применения jpath'ов является нодесет (возможно пустой).


### Примеры

На вход шаблонизатора подается js-ный объект, он представляется внутри в виде
[дерева нод](nodes-and-nodesets.md).

    data = {
        id: 42,
        hello: 'Hello, World',
        item: [
            { id: 1, title: 'First' },
            { id: 2, title: 'Second', selected: true }
            { id: 3, title: 'Third' }
        ],
        foo: { id: 4, title: 'Foo' }
    }

В левое колонке — jpath, в правой кусок ноды — имя и данные (опущены поля `parent` и `doc):

    jpath                       name        data
    ----------------------------------------------------------------------------------

    .id                         'id'        42

    .foo                        'foo'       { id: 4, title: 'Foo' }

    .foo.id                     'id'        4

    .item                       'item'      { id: 1, title: 'First' }
                                'item'      { id: 2, title: 'Second', selected: true }
                                'item'      { id: 3, title: 'Third' }

    .item[ .selected ]          'item'      { id: 2, title: 'Second', selected: true }

    .item[2]                    'item'      { id: 3, title: 'Third' }

    .item[ .id > 1 ].title      'title'     'Second'
                                'title'     'Third'

    .foo.*                      'id'        4
                                'title'     'Foo'

    .item.id                    'id'        1
                                'id'        2
                                'id'        3

    .hello[ /.id == 42 ]        'hello'     'Hello, World'

    .bar                        -


### Шаги

Каждый jpath это последовательность инструкций-шагов, которые мы выполняем,
начиная с заданного контекста.

Бывает несколько типов шагов:

  * Root
  * Nametest
  * Startest
  * Predicate
  * Index
  * Global predicate

Контекст — это обычно нодесет.
Иногда это нода, но в этом случае мы преобразуем ее в нодесет,
состоящий из этой одной ноды.

Алгоритм вычисления jpath'а такой:

  * Берем начальный нодесет.

  * К каждой ноде этого нодесета применяем первый шаг.
    Результаты (это нодесеты) склеиваем в один нодесет.
    Если получился пустой нодесет, то заканчиваем работу,
    результатом jpath'а будет пустой нодесет.

  * К каждой ноде того, что получилось, применяем второй шаг.
    Результаты склеиваем, проверяем на пустоту.

  * ...


### Root

Пример: `/`.

Jpath'ы бывают относительными и абсолютными.
Если первый символ jpath'а — это `/`, то это абсолютный jpath.
Абсолютный — значит мы начинаем его вычисление не с текущего контекста,
а с корневой ноды.


    `/.foo`
    `/.foo.bar`


### Nametest

Пример: `.foo`.

Если словами, то мы берем контекстную ноду (`context`), берем ее данные (`context.data`),
смотрим на `context.data.foo` (в данном примере), если это не `undefined`, создаем ноду,
у которой имя — `'foo'`, в качестве данных будет `context.data.foo`, а родителем — `context`.
(В js это переход от объекта к его свойству: `data -> data.foo`).

Контекстная нода:

    context = {
        ...
        data: {
            foo: { ... }
        },
        ...
    }

Результатом `.foo` будет такая нода:

    fooNode = {
        name: 'foo',
        data: context.data.foo,
        parent: context,
        ...
    }

На самом деле, результатом будет не нода, а нодесет, состоящий из этой одной ноды.
Если в `context.data.foo` ничего нет (`undefined`), то результатом будет пустой нодесет.

Если `context.data.foo` — это массив, то на выходе будет несколько нод:

    [
        {
            name: 'foo',
            data: context.data[0].foo,
            parent: context,
            ...
        },
        {
            name: 'foo',
            data: context.data[1].foo,
            parent: context,
            ...
        },
        ...
    ]

В результат, конечно, попадают только те ноды, у которых `context.data[i].foo !== undefined`.


### Startest

Пример: `.*`.

Мы берем контекстную ноду `context`, берем объект с ее данными `context.data`.
Дальше для каждого ключа `foo` в этом объекте, делаем nametest `.foo`.

На псевдо-коде:

    var result = [];
    for (var key in context.data) {
        result = result.concat( nametest(context, key) );
    }


### Predicate

Пример: `[ .selected ]`.

Предикат — это фильтр, применяющийся к текущему результату.
Например, у нас есть такой jpath: `.item[ .selected ]`.
Первым шагом (`.item`) мы получаем какой-то нодесет.

Внутри `[ ... ]` находится выражение с типом `boolean`.
Это выражение вычисляется для каждой ноды из этого нодесета.
Результатом применения предиката будут те ноды, для которых выражение истинно.


### Index

Пример: `[3]`.

Результатом будет нодесет, состоящий из одной ноды, расположенной по заданному индексу.
Или же пустой нодесет, если по этому индексу ничего нет.

    .item[0]
    .item[n]
    .item[/.n]


### Guard (global predicate)

Пример: `[ /.foo == 42 ]`.

Глобальный предикат — это некое глобальное условие, не зависящее от нодесета,
к которому оно применяется.
Если условие истинно, то мы просто переходим к следующему шагу, если же ложно —
результатом будет пустой нодесет.

Т.е. это некий аналог `if`:

    items = .item[ /.foo == 42 ]

    //  Тоже самое.
    items = if .foo == 42 {
        .item
    }


### Predicate vs index vs guard

В квадратных скобках может быть три разных типа выражений.
Отличаются они не синтаксисом, а семантикой.

  * Предикат — это выражение, которое зависит от контекста, т.е. от текущей ноды нодесета,
    который мы фильтруем. Например:

        [ .selected ]
        [ .id > 3 ]
        [ foo(.bar) ]
        [ index() < 5 ]

    Т.е. это либо использование неабсолютного jpath'а (который будет вычисляться
    в контексте каждой ноды нодесета), либо же использование функции, которая зависит от контекста.
    `index()` меняется в зависимости от ноды нодесета. Еще пример:

        func selected() {
            .selected
        }

        match / {
            for .item[ selected() ] {
                .id
            }
        }

    Здесь значение функции `selected()` зависит от текущей ноды, поэтому `[ selected() ]` — это предикат-фильтр.

  * Индекс — это глобальное (не локальное, не зависящее от контекста) скалярное выражение.

    Важный пример:

        match .item {
            title = /.titles[ index() ]

            <div>{ title }</div>
        }

    Вот здесь `[ index() ]` — это не индекс, а предикат. Потому, что `index()` зависит от контекста.
    И это выражение ложно для нулевого элемента нодесета (`index() == 0`) и истинно для всех остальных.
    Т.е. результатом применения этого предиката будут все элементы `/.titles` кроме нулевого.
    После чего, мы приводим получившийся нодесет к скаляру и все время получаем элемент с индексом `1`.
    Что не совсем то, чего мы хотели. Правильный вариант:

        match .item {
            i = index()

            title = /.titles[i]

            <div>{ title }</div>
        }

    Выражение `[i]` – это уже индекс, потому что `i` не зависит от элементов нодесета `/.titles`.

  * Глобальный предикат. Или же гвард. Это глобальное выражение с типом `boolean`.

        is-dev = true()

        match / {
            items = .item[ is-dev ]
        }

    Вот тонкий момент:

        is-dev = .config.dev

        match / {
            //  Неправильно. Это индекс!
            items = .item[ is-dev ]
        }

    Выражение `.config.dev` хоть и глобально, но тип у него `nodeset`, а не `boolean`.
    Поэтому `[ is-dev ]` здесь это индекс! Видимо, не то, что хотелось. Вот так правильно:

        is-dev = boolean(.config.dev)
        //  Или так:
        //  is-dev = !!.config.dev

        match / {
            items = .item[ is-dev ]
        }

    Тут мы явно привели выражение к `boolean`, так что теперь это гвард.

