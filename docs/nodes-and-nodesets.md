## Деревья, ноды и нодесеты

На вход шаблонизатора подается javascript'овый объект (дерево),
но внутри шаблоназитора используется другое дерево — дерево нод.

### Ноды

Например, у нас есть такой js-объект:

    data = {
        id: 42,
        hello: 'Hello, World',
        item: [
            { id: 1, title: 'First' },
            { id: 2, title: 'Second', selected: true }
            { id: 3, title: 'Third' }
        ]
    }

Внутри он представляется вот таким деревом нод.
Одна строчка — одна нода, показано имя ноды и данные ноды:

    '' data
        'id' 42
        'hello' 'Hello, World'
        'item' { id: 1, title: 'First' }
            'id' 1
            'title' 'First'
        'item' { id: 2, title: 'Second', selected: true }
            'id' 2
            'title' 'Second'
            'selected' true
        'item' { id: 3, title: 'Third' }
            'id' 3
            'title 'Third'

Нода — это структура вида:

    {
        name: String
        data: Object
        parent: Node
        doc: Doc
    }

  * `name` — это строка, содержащая имя ноды. У любой ноды есть имя.
    Единственная нода, у которой в качестве имени пустая строка — корневая нода.

  * `data` — собственно данные ноды.
    У корневой ноды в `data` лежит весь исходный объект,

  * `parent` — ссылка на родительскую ноду. У корневой ноды нет родителя,
    так что значение `parent` у нее `null`.
    Из любой ноды в дереве, следуя по ссылкам `parent` можно дойти до корневой ноды.

  * `doc` — ссылка на документ (специальный объект, см. ниже), которому принадлежит нода.
    В документе, помимо всего прочего, содержится ссылка на корневую ноду (`doc.root`).

Т.е. (если отбросить два служебных поля `parent` и `doc`) нода это имя и данные.
Дерево начинается с корневой ноды, у которой нет имени (пустая строка) и в качестве данных —
весь исходный js-объект.
Мы можем спускаться вниз по дереву при помощи [jpath](jpath.md), по пути создавая соответствующие ноды:

Например, мы стартуем с такой корневой ноды:

    //  Исходные данные.
    data = {
        foo: {
            bar: {
                ...
            }
        },
        ...
    }

    //  Корневая нода.
    rootNode = {
        name: '',
        data: data,
        parent: null,
        doc: doc
    }

и при помощи jpath'а `.foo` получаем ноду:

    fooNode = {
        name: 'foo',
        data: data.foo,
        parent: rootNode,
        doc: doc
    }

И идем ниже до `.foo.bar`:

    barNode = {
        name: 'bar',
        data: data.foo.bar,
        parent: fooNode,
        doc: doc
    }

При этом, если мы никогда не попытаемся вычислить jpath `.foo`, то эта нода никогда и не будет создана.
Т.е. мы не обходим сразу весь js-объект целиком и не строим сразу  дерево нод — это слишком дорого.
Плюс далеко не все ноды нам понадобятся для шаблонизации.
Но, для того, чтобы получить `barNode`, нам придется по пути создать все промеждуточные ноды
(в нашем случае `fooNode`).

Обратите внимание, что в ноде есть ссылка только на родителя. А, например, на потомков — нет.
Потомков мы создаем по мере того, как вычисляем jpath'ы от этой ноды. Ссылки на них не сохраняются.
Ссылка на родителя нужно лишь для того, чтобы была возможность понять, что нода матчится на jpath типа:

    match .foo.bar {
        ...
    }

Этот шаблон может примениться к ноде с именем `'bar'`, у которой родитель имеет имя `'foo'`.


Грубо правило, по которому происходит соответствие частей js-объекта и нод.
Каждое `:` — это нода. Плюс всегда есть корневая нода:

    {
        foo: {
            bar: 'hello'
        }
    }

— тут три ноды: корневая, `.foo` и `.foo.bar`.

Правило "одно `:` — одна нода" не выполняется, если справа от `:` стоит массив:

    {
        foo: [ 1, 2, 3 ]
    }

Здесь каждый элемент массива дает одну ноду.
Можно себе представлять, что мы записываем массив в виде такого объекта:

    {
        foo: 1,
        foo: 2,
        foo: 3
    }

Это, конечно, нелегальная в js конструкция — у объекта не может быть нескольких полей с одним названием
(в отличие от xml-ных деревьев). Поэтому мы используем массивы для эмуляции таких объектов.

У каждой ноды должно быть имя, но какое имя выдать вот таким нодам:

    [ 'First', 'Second', 'Third' ]

В случае если мы подадим на вход "анонимный" массив, то он будет автоматически
преобразован в такой объект:

    {
        item: [ 'First', 'Second', 'Third' ]
    }

Т.е. мы считаем, что все такие ноды имеют имя `'item'`.

Вложенные массивы:

    [
        [ 1, 2, 3 ],
        [ 4, 5, 6 ],
        [ 7, 8, 9 ]
    ]

мы представляем как:

    {
        item: [
            { item: [ 1, 2, 3 ] },
            { item: [ 4, 5, 6 ] },
            { item: [ 7, 8, 9 ] }
        ]
    }

(На самом деле, в данный момент вложенные массивы не работают. Это баг)


### Нодесеты

`Node` это структура, которая используется внутри `yate` повсеместно, но снаружи,
для пользователей `yate` (для тех, кто пишет шаблоны), доступны только нодесеты.

`Nodeset` — это массив нод. Даже если у нас есть выборка из одной ноды, это все равно
будет нодесет из одной ноды.
Вся работа с нодами в шаблонизаторе происходит на уровне нодесетов.

Результат вычисления любого jpath — это нодесет (возможно, пустой).

### Документ

В каждой ноде есть ссылка на объект, называемый документом.
Документ это инстанс некоего приватного класса, в котором хранится
разная информация, общая для всех нод, созданных из исходного js-объекта.

Помимо ссылки на корневую ноду, там хранятся вычисленные значения глобальных переменных и ключей.



