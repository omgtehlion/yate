Changelog
=========

0.0.76
------

  * Fixed #242.
  * Fixed #243.

0.0.75
------

  * Fixed #234. Оказывается, проверка на `is_matchable` была,
    но, похоже, в процессе рефакторинга там опечатка случилась и она сломалась.
    Теперь вот такое будет падать при компиляции:

        match .foo[ /.bar ] {

        }

    Вместо этого, нужно писать так:

        match .foo[ !!/.bar ] {

        }

0.0.74
------

  * Merged #235. Починена опция `--write-ast`.

0.0.73
------

  * Блок внутри массива может создавать несколько элементов массива,
    в том числе и разнородных:

        [
            for .item {
                {
                    "foo": 42
                }
                {
                    "bar": 24
                }
                42
                true()
            }
        ]

0.0.72
------

  * Флаг `--module-name` (#228):

        yate foo.yate --module-name "foo"
        yate /foo/bar.yate --module-name "/foo/bar.yate"

    Если в модуле не задано имя директивой `module "foo"`, то сперва берется
    имя из этого параметра (если он есть), а если нет, то используется
    дефолтное значение `"main"`.

  * В методы `yate.parse()`, `yate.compile()`, `yate.run()` теперь вторым
    параметром передается список опций (в случае запуска из командной строк,
    он содержит параметры из разобранной командной строки):

        var js = yate.compile( 'foo.yate', { 'module-name': 'bar' } );

    **Внимание**. У `yate.run` поменялась сигнатура (у `yate.parse` и `yate.compile`
    просто не было второго параметра, теперь он есть и опциональный).
    Для симметрии (ха-ха), опции передаются тоже вторым параметром, поэтому
    остальные параметры сдвинулись на один:

        //  Было.
        yate.run = function(yate_filename, data, ext_filename, mode) {
            ...
        };

        //  Стало.
        yate.run = function(yate_filename, options, data, ext_filename, mode) {
            ...
        };

0.0.71
------

  * Merged #227. Метод `yr.isRegistered(id)`.

0.0.70
------

  * В `runtime.js` повсюду использовалась конструкция `foo instanceof Array`,
    которая не работает, например, когда шаблон исполняется в ноде через модуль `vm`
    т.к. данные и шаблон используют разные `Array`.

    Начиная с этой версии, в `runtime.js` используется `Array.isArray(foo)`.

    **Важно**. `Array.isArray()` нет, например, в IE7 и IE8.
    Так что, если нужна подддержка этих (и других старых браузеров), нужно позаботиться о полифиле.
    Например, вот такой:

        if ( !Array.isArray ) {
            Array.isArray = function( a ) {
                return Object.prototype.toString.call( a ) === '[object Array]';
            };
        }

    или даже (в браузере, если нет нескольких фреймов):

        if ( !Array.isArray ) {
            Array.isArray = function( a ) {
                return ( a instanceof Array );
            };
        }

    Я не стал добавлять это в `runtime.js` автоматически.

0.0.69
------

  * Fixed #103. Аналог `current()`.
  * Fixed #163. Тернарный оператор.

0.0.68
------

  * Merged #196. "Неймспейсы" в xml-атрибутах.

0.0.67
------

  * Fixes #218.

0.0.66
------

  * Fixed #170. Рекурсивные функции и hoisting. См. тесты `tests/function.[24, 25, 26, 28, 29].yate`.
    Могут сломаться юзерские функции, имя которых совпадает с одним из типов. Например, `xml`.

0.0.65
------

  * Пофикшен тест `tests/jpaths.22.yate`.
    `simpleScalar` выдавал `undefined` (вместо пустой строки), если по jpath'у ничего не было.

0.0.64
------

  * Попытка пофиксить #198. Объекты и массивы в аргументах функции должны приводиться к нодесету,
    если так написано в сигнатуре функции.

0.0.63
------

  * Fixes `tests/json.23.yate`. `for` внутри массива должен вычислять свой тип по-другому.
    Так чтобы, например, можно было сгенерить массив объектов.

0.0.62
------

  * Fixed `tests/jpaths.21.yate`. Ноль при приведении к скаляру должен давать `'0'`, а не `''`.

0.0.61
------

  * Fixed #209. Глобальная переменная всегда вычисляется в глобальном контексте,
    а не в том контексте, где к ней впервые обратились.

0.0.60
------

  * Fixed #202. Поддержка произвольных строк в jpath nametest.

0.0.59
------

  * Merged #201. Какая-то поддержка вложенных массивов.

0.0.58
------

  * Merged #199. parse-tools -> 0.0.17

0.0.57
------

  * Временно возвращаем возможность использовать `include` внутри блоков,
    не на верхнем уровне файла.

0.0.54 — 0.0.56
---------------

  * Ловили странный баг, добавляли логирование, потом все оторвали.

0.0.53
------

  * В runtime'е вместо `s.toString()` используем `'' + s`.
    Потенциально, это фиксит странный баг в Сафари.

0.0.52
------

  * Fixed #195.

0.0.51
------

  * Меняем местами аргументы `subnode()`:

        subnode("foo", 42)

        subnode("foo", {
            "bar": 24
        })

0.0.50
------

  * Функция `subnode`, которая делает примерно то же самое, что и `document`,
    но не меняет контекст документа:

        apply subnode(42, "foo")

        bar = {
            "bar": 24
        }
        apply subnode(bar, "foo")

    В этих примерах будет создана нода с именем `"foo"`, подклеенная к текущему контексту.
    Т.е. примерно как:

        //  Условно.
        this.foo = 42;
        apply .foo

        //  Условно.
        this.foo = {
            bar: 24
        };
        apply .foo

    У этой новой ноды родителем будет текущий контекст.

    См. [tests/json.22.yate](tests/json.22.yate).

0.0.49
------

  * Fixed #188.

0.0.48
------

  * Fixed #189.

0.0.47
------

  * Правильные версии nommon и parse-tools.

0.0.46
------

  * Fixed #179.

0.0.45
------

  * Более-менее пофикшен #175.

0.0.44
------

  * Частично пофикшен #181. См. тесты `spaces.*.yate`.

0.0.43
------

  * Fixed #178.

0.0.42
------

  * Fixed #172 (вроде бы).

0.0.41
------

  * Fixed #171

0.0.40
------

  * Изменен синтаксис атрибутов с динамическим именем.
    Было:

        @{ .name } = 42
        @{ "data-{ .name }" } = 24

    Стало:

        @{ .name } = 42
        @data-{ .name } = 24

    Т.е. статические куски имени (строковые литералы) не нужно заключать в кавычки.

